generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                      ENUMS
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum PersonSubscriptionPlan {
  FREEMIUM
  BASIC
  ADVANCED
}

enum BusinessSubscriptionPlan {
  FREEMIUM
  STARTUP
  BASIC
  ADVANCED
  EXPERT
}

enum AdvertisementType {
  HERO_BANNER
  CATEGORY_HIGHLIGHT
  PRODUCT_HIGHLIGHT
  FEED_AD_BANNER
  NEWSLETTER_SPOTLIGHT
  PROMOTIONAL_SEARCH
  SOCIAL_MEDIA_SPOTLIGHT
  MONTHLY_PACKAGE
}

// Platform admins vs Business admins
enum AdminType {
  PLATFORM // Ekoru staff members
  BUSINESS // Seller team members
}

// Roles for both platform and business admins
enum AdminRole {
  // Platform roles (Ekoru staff)
  SUPER_ADMIN // Full system access
  MODERATOR // Moderate content, products, users
  CONTENT_MANAGER // Manage blog, marketing content
  SUPPORT // Customer support access

  // Business roles (Seller team members)
  BUSINESS_OWNER // Full access to their business
  BUSINESS_MANAGER // Manage products, orders, team
  BUSINESS_ANALYST // Read-only analytics access
  BUSINESS_SUPPORT // Handle customer inquiries
}

// Granular permissions for fine-grained access control
enum AdminPermission {
  // Product Management
  MANAGE_PRODUCTS
  APPROVE_PRODUCTS
  DELETE_PRODUCTS

  // Content Management
  WRITE_BLOG
  PUBLISH_BLOG
  DELETE_BLOG
  MODERATE_CONTENT

  // User Management
  MANAGE_USERS
  BAN_USERS
  VIEW_USER_DATA

  // Order & Transaction Management
  MANAGE_ORDERS
  PROCESS_REFUNDS
  VIEW_TRANSACTIONS
  VIEW_ANALYTICS
  EXPORT_DATA

  // Platform Management (Platform admins only)
  MANAGE_ADMINS
  MANAGE_CATEGORIES
  MANAGE_SETTINGS
  VIEW_SYSTEM_LOGS

  // Business Management (Business admins only)
  MANAGE_BUSINESS_PROFILE
  MANAGE_BUSINESS_TEAM
  VIEW_BUSINESS_ANALYTICS
  MANAGE_BUSINESS_PRODUCTS
  MANAGE_BUSINESS_ORDERS
}

enum Badge {
  POPULAR
  DISCOUNTED
  WOMAN_OWNED
  BEST_SELLER
  TOP_RATED
  COMMUNITY_FAVORITE
  LIMITED_TIME_OFFER
  FLASH_SALE
  BEST_VALUE
  HANDMADE
  SUSTAINABLE
  SUPPORTS_CAUSE
  FAMILY_BUSINESS
  CHARITY_SUPPORT
  LIMITED_STOCK
  SEASONAL
  FREE_SHIPPING
  FOR_REPAIR
  REFURBISHED
  EXCHANGEABLE
  LAST_PRICE
  FOR_GIFT
  OPEN_TO_OFFERS
  OPEN_BOX
  CRUELTY_FREE
  DELIVERED_TO_HOME
  IN_HOUSE_PICKUP
  IN_MID_POINT_PICKUP
}

enum BlogType {
  RECYCLING
  POLLUTION
  SUSTAINABILITY
  CIRCULAR_ECONOMY
  USED_PRODUCTS
  REUSE
  ENVIRONMENT
  UPCYCLING
  RESPONSIBLE_CONSUMPTION
  ECO_TIPS
  ENVIRONMENTAL_IMPACT
  SUSTAINABLE_LIVING
  OTHER
  SECURITY
}

enum BlogReactionType {
  LIKE
  DISLIKE
}

enum BusinessType {
  RETAIL
  SERVICES
  MIXED
}

enum ChileanPaymentProvider {
  KHIPU // Primary - Bank transfers
  WEBPAY // Backup - Credit/Debit cards (Transbank)
}

enum ContactMethod {
  EMAIL
  WHATSAPP
  PHONE
  INSTAGRAM
  FACEBOOK
  WEBSITE
  TIKTOK
}

enum ExchangeStatus {
  PENDING
  ACCEPTED
  DECLINED
  COMPLETED
  CANCELLED
}

enum NotificationPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum NotificationType {
  ORDER_RECEIVED
  ORDER_CONFIRMED
  ORDER_SHIPPED
  ORDER_DELIVERED
  ORDER_CANCELLED
  QUOTATION_REQUEST
  QUOTATION_RECEIVED
  QUOTATION_ACCEPTED
  QUOTATION_DECLINED
  EXCHANGE_PROPOSAL
  EXCHANGE_ACCEPTED
  EXCHANGE_DECLINED
  EXCHANGE_COMPLETED
  PAYMENT_RECEIVED
  PAYMENT_FAILED
  PAYMENT_REFUNDED
  REVIEW_RECEIVED
  MESSAGE_RECEIVED
  PRODUCT_LIKED
  PRODUCT_COMMENTED
  SYSTEM_ANNOUNCEMENT
  ACCOUNT_VERIFICATION
  PROFILE_UPDATED
}

enum PaymentEnvironment {
  SANDBOX
  PRODUCTION
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
  PARTIALLY_REFUNDED
  EXPIRED // For expired payment links
}

enum PaymentType {
  ORDER // Payment for store products
  QUOTATION // Payment for services
}

enum ProductCondition {
  NEW
  OPEN_BOX
  LIKE_NEW
  FAIR
  POOR
  FOR_PARTS
  REFURBISHED
}

enum ProductSize {
  XS
  S
  M
  L
  XL
}

enum QuotationStatus {
  PENDING
  ACCEPTED
  DECLINED
  COMPLETED
  CANCELLED
  EXPIRED
}

enum RefundStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum SellerType {
  PERSON
  STARTUP
  COMPANY
}

enum ServicePricing {
  FIXED
  QUOTATION
  HOURLY
  PACKAGE
}

enum ShippingStage {
  PREPARING
  SHIPPED
  DELIVERED
  RETURNED
  CANCELED
}

enum TransactionKind {
  PURCHASE
  SELL
  STOREPURCHASE
  EXCHANGE
  RECYCLE
  REPAIR
  ATTENDTOWORKSHOP
  ATTENDTOEVENT
}

enum WeightUnit {
  KG
  LB
  OZ
  G
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                      SELLER CATEGORIES AND LEVELS
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
model SellerLabel {
  id                   Int                    @id @default(autoincrement())
  labelName            String                 @unique
  transactionKind      TransactionKind
  transactionsRequired Int
  description          String? // e.g., "Complete 5 second-hand purchases"
  badgeIcon            String? // Icon/image URL for the badge
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt

  // Relations - sellers who have achieved this label
  achievedBy SellerAchievedLabel[]

  @@index([transactionKind])
  @@index([transactionsRequired])
}

// Junction table to track which sellers have earned which labels
// WHY NECESSARY: Allows tracking WHEN labels were earned, current progress, and prevents duplicate achievements
model SellerAchievedLabel {
  id          Int      @id @default(autoincrement())
  sellerId    String
  labelId     Int
  achievedAt  DateTime @default(now()) // When the seller earned this badge
  
  // Progress tracking (optional but useful)
  currentCount Int? // Current transaction count for this type (e.g., "7 purchases done, need 15 for next badge")
  
  seller Seller      @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  label  SellerLabel @relation(fields: [labelId], references: [id], onDelete: Cascade)

  @@unique([sellerId, labelId]) // Prevent duplicate achievements - one seller can't earn same badge twice
  @@index([sellerId])
  @@index([labelId])
  @@index([achievedAt])
}

model PointsByTransactionKind {
  id              Int             @id @default(autoincrement())
  transactionKind TransactionKind @unique
  pointsAwarded   Int
  description     String? // e.g., "Points awarded per second-hand purchase"
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([transactionKind])
}

model SellerLevel {
  id        Int      @id @default(autoincrement())
  levelName String   @unique
  minPoints Int      @unique // Minimum points required for this level
  maxPoints Int? // Maximum points (null for highest level)
  benefits  Json? // Perks, discounts, features unlocked at this level
  badgeIcon String? // Visual badge for this level
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  sellers Seller[]

  @@index([minPoints])
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                      MEMBERSHIPS, ADS AND FEES
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
model PersonMembership {
  id             Int                    @id @default(autoincrement())
  membershipType PersonSubscriptionPlan @default(FREEMIUM)
  price          Int
  description    String[]
  durationMonths Int
  startDate      DateTime               @default(now())
  endDate        DateTime?
  isActive       Boolean                @default(true)
  autoRenew      Boolean                @default(false)
  createdAt      DateTime               @default(now())
  updatedAt      DateTime               @updatedAt

  // Relations
  personProfiles PersonProfile[] // Users subscribed to this membership plan

  @@index([membershipType])
  @@index([isActive])
}

model BusinessMembership {
  id             Int                      @id @default(autoincrement())
  membershipType BusinessSubscriptionPlan @default(FREEMIUM)
  price          Int
  description    String[]
  durationMonths Int
  startDate      DateTime                 @default(now())
  endDate        DateTime?
  isActive       Boolean                  @default(true)
  autoRenew      Boolean                  @default(false)
  createdAt      DateTime                 @default(now())
  updatedAt      DateTime                 @updatedAt

  // Relations
  businessProfiles BusinessProfile[] // Businesses subscribed to this membership plan

  @@index([membershipType])
  @@index([isActive])
}

model TransactionFee {
  id            Int        @id @default(autoincrement())
  sellerTypeFee SellerType
  feePercentage Float      @default(0.0)
  description   String

  // Relations
  transactions Transaction[]

  @@index([sellerTypeFee])
  @@index([feePercentage])
}

// IMPORTANT: Advertisements are ONLY available for BUSINESS sellers
// Application must enforce: only sellers where seller.sellerType = 'STARTUP' or 'COMPANY' can purchase ads
// PERSON sellers cannot purchase advertisements
// This is enforced at the application level, not in the database
model Advertisement {
  id        Int               @id @default(autoincrement())
  adType    AdvertisementType
  price     Int
  content   String
  startDate DateTime
  endDate   DateTime
  isActive  Boolean           @default(true)

  // Seller who purchased the ad (MUST be STARTUP or COMPANY type)
  sellerId String
  seller   Seller @relation(fields: [sellerId], references: [id], onDelete: Cascade)

  // Optional: Link to specific product or service being advertised
  productId Int?
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull)

  storeProductId Int?
  storeProduct   StoreProduct? @relation(fields: [storeProductId], references: [id], onDelete: SetNull)

  serviceId Int?
  service   Service? @relation(fields: [serviceId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sellerId])
  @@index([adType])
  @@index([isActive])
  @@index([startDate, endDate])
  @@index([productId])
  @@index([storeProductId])
  @@index([serviceId])
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                      LOCATION
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
model Country {
  id            Int            @id @default(autoincrement())
  country       String
  region        Region[]
  seller        Seller[]
  admin         Admin[]
  countryConfig CountryConfig?
}

// Multi-country expansion configuration
// Currently focused on Chile, prepared for expansion to other LATAM countries
model CountryConfig {
  id              Int     @id @default(autoincrement())
  countryId       Int     @unique
  countryCode     String  @unique // "CL", "AR", "PE", "MX", etc.
  currencyCode    String // "CLP", "ARS", "PEN", "MXN"
  currencySymbol  String // "$", "S/", etc.
  taxIdLabel      String // "RUT" (Chile), "CUIT" (Argentina), "RUC" (Peru)
  taxIdFormat     String? // Regex or format string for validation
  defaultTimezone String // "America/Santiago", "America/Buenos_Aires"
  defaultLocale   String // "es-CL", "es-AR", "es-PE"
  isActive        Boolean @default(false) // Only Chile is active initially
  phonePrefix     String // "+56", "+54", "+51"

  // Payment provider availability per country
  availablePaymentProviders Json // Array of available providers for this country

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  country Country @relation(fields: [countryId], references: [id])

  @@index([countryCode])
  @@index([isActive])
}

model Region {
  id        Int      @id @default(autoincrement())
  region    String
  countryId Int
  city      City[]
  country   Country  @relation(fields: [countryId], references: [id])
  seller    Seller[]
  admin     Admin[]
}

model City {
  id       Int      @id @default(autoincrement())
  city     String
  regionId Int
  region   Region   @relation(fields: [regionId], references: [id])
  county   County[]
  seller   Seller[]
  admin    Admin[]
}

model County {
  id     Int      @id @default(autoincrement())
  county String
  cityId Int
  city   City     @relation(fields: [cityId], references: [id])
  seller Seller[]
  admin  Admin[]
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                      Admin
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
model Admin {
  id       String  @id @default(uuid())
  email    String  @unique
  password String
  name     String
  lastName String?

  // Admin type and access control
  adminType   AdminType         @default(PLATFORM)
  role        AdminRole         @default(MODERATOR)
  permissions AdminPermission[] // Granular permissions

  // Location
  countryId Int?
  country   Country? @relation(fields: [countryId], references: [id])
  regionId  Int?
  region    Region?  @relation(fields: [regionId], references: [id])
  cityId    Int?
  city      City?    @relation(fields: [cityId], references: [id])
  countyId  Int?
  county    County?  @relation(fields: [countyId], references: [id])

  // Business admin relation (null for platform admins)
  sellerId String?
  seller   Seller? @relation(fields: [sellerId], references: [id], onDelete: Cascade)

  // Account status and security
  isActive        Boolean   @default(true)
  isEmailVerified Boolean   @default(false)
  accountLocked   Boolean   @default(false)
  loginAttempts   Int       @default(0)
  lastLoginAt     DateTime?
  lastLoginIp     String?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  blogPost         BlogPost[]
  communityPost    CommunityPost[]
  adminActivityLog AdminActivityLog[]

  @@index([email])
  @@index([sellerId])
  @@index([adminType])
  @@index([isActive])
}

// Audit trail for admin actions
model AdminActivityLog {
  id         Int      @id @default(autoincrement())
  adminId    String
  action     String // e.g., "CREATE_PRODUCT", "DELETE_USER", "PUBLISH_BLOG"
  entityType String? // e.g., "Product", "User", "BlogPost"
  entityId   String? // ID of the affected entity
  changes    Json? // Before/after data for auditing
  ipAddress  String?
  userAgent  String?
  metadata   Json? // Additional context
  createdAt  DateTime @default(now())

  admin Admin @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
  @@index([action])
  @@index([entityType])
  @@index([createdAt])
  @@index([adminId, createdAt(sort: Desc)]) // Recent activity by admin
  @@index([entityType, entityId]) // All actions on specific entity
  @@index([action, createdAt(sort: Desc)]) // Recent actions by type
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                               Seller And Profiles
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
model Seller {
  id                     String         @id     @default(uuid())
  email                  String         @unique
  password               String
  sellerType             SellerType
  isActive               Boolean        @default(true)
  isVerified             Boolean        @default(false)
  createdAt              DateTime       @default(now())
  updatedAt              DateTime       @updatedAt
  address                String?        @default("")
  cityId                 Int?
  countryId              Int?
  countyId               Int?
  regionId               Int?
  phone                  String?        @default("")
  website                String?
  preferredContactMethod ContactMethod? @default(WHATSAPP)
  socialMediaLinks       Json?
  points                 Int            @default(0)
  sellerLevelId          Int?
  sellerLevel            SellerLevel?   @relation(fields: [sellerLevelId], references: [id])
  
  // Gamification - Achieved labels (many-to-many through junction table)
  achievedLabels SellerAchievedLabel[]

  // Profile Relations - Each seller has ONE profile based on sellerType
  personProfile   PersonProfile? // For PERSON type
  businessProfile BusinessProfile? // For STARTUP and COMPANY types

  // Admin Team - Business admins who can manage this seller account
  admin Admin[]

  // Advertising and Memberships
  advertisement Advertisement[]

  chat_Chat_receiverIdToSeller           Chat[]                 @relation("Chat_receiverIdToSeller")
  chat_Chat_senderIdToSeller             Chat[]                 @relation("Chat_senderIdToSeller")
  chileanPaymentConfig                   ChileanPaymentConfig[]
  communityComment                       CommunityComment[]
  match_Match_receiverIdToSeller         Match[]                @relation("Match_receiverIdToSeller")
  match_Match_senderIdToSeller           Match[]                @relation("Match_senderIdToSeller")
  message                                Message[]
  notification                           Notification[]
  order                                  Order[]
  payment_Payment_payerIdToSeller        Payment[]              @relation("Payment_payerIdToSeller")
  payment_Payment_receiverIdToSeller     Payment[]              @relation("Payment_receiverIdToSeller")
  product                                Product[]
  storeProduct                           StoreProduct[]
  productComment                         ProductComment[]
  productLike                            ProductLike[]
  blogReaction                           BlogReaction[]
  quotation_Quotation_clientIdToSeller   Quotation[]            @relation("Quotation_clientIdToSeller")
  quotation_Quotation_providerIdToSeller Quotation[]            @relation("Quotation_providerIdToSeller")
  city                                   City?                  @relation(fields: [cityId], references: [id])
  country                                Country?               @relation(fields: [countryId], references: [id])
  county                                 County?                @relation(fields: [countyId], references: [id])
  region                                 Region?                @relation(fields: [regionId], references: [id])
  sellerPreferences                      SellerPreferences?
  service                                Service[]
  serviceReview                          ServiceReview[]
  story                                  Story[]
  transaction                            Transaction[]

  @@index([cityId])
  @@index([email])
  @@index([isActive])
  @@index([isVerified])
  @@index([sellerType])
  @@index([sellerType, isActive]) // Active sellers by type
  @@index([sellerLevelId]) // Sellers by level
  @@index([points(sort: Desc)]) // Top sellers by points
  @@index([createdAt(sort: Desc)]) // Recently joined sellers
}

model SellerPreferences {
  id                 Int     @id @default(autoincrement())
  sellerId           String  @unique
  preferredLanguage  String? @default("es")
  currency           String? @default("CLP")
  emailNotifications Boolean @default(true)
  pushNotifications  Boolean @default(true)
  orderUpdates       Boolean @default(true)
  communityUpdates   Boolean @default(true)
  securityAlerts     Boolean @default(true)
  weeklySummary      Boolean @default(false)
  twoFactorAuth      Boolean @default(false)
  seller             Seller  @relation(fields: [sellerId], references: [id], onDelete: Cascade)
}

model PersonProfile {
  id             String    @id @default(uuid())
  sellerId       String    @unique
  firstName      String
  lastName       String?
  displayName    String?
  bio            String?
  birthday       DateTime?
  profileImage   String?
  coverImage     String?
  allowExchanges Boolean   @default(true) // Only PERSON users can exchange

  // Active membership subscription
  personMembershipId Int?
  personMembership   PersonMembership? @relation(fields: [personMembershipId], references: [id])

  seller Seller @relation(fields: [sellerId], references: [id], onDelete: Cascade)

  @@index([personMembershipId])
  @@index([sellerId])
}

model BusinessProfile {
  id       String @id @default(uuid())
  sellerId String @unique

  // Basic Information
  businessName String // Nombre comercial
  description  String?
  logo         String?
  coverImage   String?
  businessType BusinessType // RETAIL, SERVICES, MIXED

  // Chilean Legal Requirements
  legalBusinessName        String? // Razón Social (legal business name)
  taxId                    String?   @unique // RUT - Rol Único Tributario (Chilean Tax ID)
  businessStartDate        DateTime? // Inicio de Actividades (SII registration date)
  legalRepresentative      String? // Representante Legal (legal representative name)
  legalRepresentativeTaxId String? // RUT of legal representative

  // For RETAIL and MIXED
  shippingPolicy String?
  returnPolicy   String?

  // For SERVICES and MIXED
  serviceArea       String?
  yearsOfExperience Int?
  certifications    String[]
  travelRadius      Int? // In kilometers

  // Operating Hours
  businessHours Json? // Store/service hours

  // Active membership subscription
  businessMembershipId Int?
  businessMembership   BusinessMembership? @relation(fields: [businessMembershipId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  seller    Seller   @relation(fields: [sellerId], references: [id], onDelete: Cascade)

  @@index([taxId])
  @@index([businessType])
  @@index([businessMembershipId])
  @@index([sellerId])
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                    Marketplace
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
model Department {
  id                 Int                  @id @default(autoincrement())
  departmentName     String
  departmentImage    String?
  departmentCategory DepartmentCategory[]
}

model DepartmentCategory {
  id                     Int               @id @default(autoincrement())
  departmentId           Int
  departmentCategoryName String
  department             Department        @relation(fields: [departmentId], references: [id])
  productCategory        ProductCategory[]
}

model ProductCategory {
  id                   Int          @id @default(autoincrement())
  departmentCategoryId Int
  keywords             String[]
  productCategoryName  String
  size                 ProductSize? @default(M)
  averageWeight        Float?       @default(0.0)
  weightUnit           WeightUnit?  @default(KG)

  // Relations
  product            Product[]
  departmentCategory DepartmentCategory        @relation(fields: [departmentCategoryId], references: [id])
  // NEW: Junction table relation for unlimited materials
  materials          ProductCategoryMaterial[]

  @@index([departmentCategoryId])
}

model ProductCategoryMaterial {
  id                Int      @id @default(autoincrement())
  productCategoryId Int
  materialTypeId    Int
  quantity          Float // Percentage or weight
  unit              String   @default("percentage") // "percentage", "kg", "g"
  isPrimary         Boolean  @default(false) // Main material
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  productCategory ProductCategory        @relation(fields: [productCategoryId], references: [id], onDelete: Cascade)
  material        MaterialImpactEstimate @relation(fields: [materialTypeId], references: [id])

  @@unique([productCategoryId, materialTypeId]) // Prevent duplicate materials
  @@index([productCategoryId])
  @@index([materialTypeId])
  @@index([isPrimary])
}

model Product {
  id                                            Int              @id @default(autoincrement())
  name                                          String
  description                                   String
  price                                         Int
  hasOffer                                      Boolean          @default(false)
  offerPrice                                    Int?             @default(0)
  sellerId                                      String
  badges                                        Badge[]
  brand                                         String
  color                                         String?
  createdAt                                     DateTime         @default(now())
  images                                        String[]
  interests                                     String[]
  isActive                                      Boolean          @default(true)
  isExchangeable                                Boolean          @default(false)
  productCategoryId                             Int
  updatedAt                                     DateTime
  condition                                     ProductCondition @default(NEW)
  conditionDescription                          String?
  deletedAt                                     DateTime? // Soft delete - null means active
  chat                                          Chat[]
  exchange_Exchange_offeredProductIdToProduct   Exchange[]       @relation("Exchange_offeredProductIdToProduct")
  exchange_Exchange_requestedProductIdToProduct Exchange[]       @relation("Exchange_requestedProductIdToProduct")
  orderItem                                     OrderItem[]
  advertisement                                 Advertisement[]
  productCategory                               ProductCategory  @relation(fields: [productCategoryId], references: [id])
  seller                                        Seller           @relation(fields: [sellerId], references: [id])

  @@index([createdAt])
  @@index([isActive])
  @@index([price])
  @@index([productCategoryId])
  @@index([sellerId])
  @@index([sellerId, isActive]) // Active products by seller
  @@index([isExchangeable, isActive]) // Find available exchangeable products
  @@index([productCategoryId, isActive]) // Active products by category
  @@index([createdAt(sort: Desc), isActive]) // Recent active products
  @@index([hasOffer, isActive]) // Products on offer
  @@index([deletedAt]) // Filter out soft-deleted products
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                    STORE
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
model StoreCategory {
  id            Int                @id @default(autoincrement())
  category      String
  subcategories StoreSubCategory[]
}

model StoreSubCategory {
  id              Int            @id @default(autoincrement())
  subCategory     String
  storeCategoryId Int
  storeCategory   StoreCategory  @relation(fields: [storeCategoryId], references: [id])
  storeProducts   StoreProduct[]
}

model StoreProduct {
  id                  Int       @id @default(autoincrement())
  name                String
  description         String
  stock               Int       @default(0)
  barcode             String?   @unique
  sku                 String?
  price               Int
  hasOffer            Boolean   @default(false)
  offerPrice          Int?
  sellerId            String
  createdAt           DateTime  @default(now())
  images              String[]
  isActive            Boolean   @default(true)
  updatedAt           DateTime
  badges              Badge[]
  brand               String?
  color               String?
  ratingCount         Int       @default(0)
  ratings             Float     @default(0)
  reviewsNumber       Int       @default(0)
  materialComposition String?
  recycledContent     Float?
  subcategoryId       Int
  deletedAt           DateTime? // Soft delete - null means active

  // Environmental impact metrics (calculated from materials)
  sustainabilityScore Int? // 0-100 score based on materials + certifications
  carbonFootprint     Float? // Total CO2 footprint in kg

  productVariant   ProductVariant[]
  advertisement    Advertisement[]
  storeSubCategory StoreSubCategory       @relation(fields: [subcategoryId], references: [id])
  seller           Seller                 @relation(fields: [sellerId], references: [id])
  // NEW: Junction table relation for upcycled materials tracking
  materials        StoreProductMaterial[]
  productComment   ProductComment[]
  productLike      ProductLike[]

  @@index([sellerId])
  @@index([subcategoryId])
  @@index([isActive])
  @@index([sellerId, isActive]) // Active products by seller
  @@index([subcategoryId, isActive]) // Active products by category
  @@index([stock]) // Low stock alerts
  @@index([hasOffer, isActive]) // Products on offer
  @@index([createdAt(sort: Desc), isActive]) // Recent products
  @@index([ratings(sort: Desc), isActive]) // Top rated products
  @@index([deletedAt]) // Filter out soft-deleted products
}

// NEW: Junction table for store products (upcycled - new from recycled materials)
// Tracks source materials used to make new products (e.g., car tires → purses)
model StoreProductMaterial {
  id                 Int      @id @default(autoincrement())
  storeProductId     Int
  materialTypeId     Int
  quantity           Float // Percentage or weight
  unit               String   @default("percentage") // "percentage", "kg", "g"
  isPrimary          Boolean  @default(false) // Main material
  // Upcycling-specific fields
  sourceMaterial     String? // e.g., "Car Tires", "Used Denim Jeans", "Plastic Bottles"
  isRecycled         Boolean  @default(true) // Material is from recycled source
  recycledPercentage Float?   @default(100) // % of this material that is recycled (0-100)
  supplierVerified   Boolean  @default(false) // Source verified by supplier
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  storeProduct StoreProduct           @relation(fields: [storeProductId], references: [id], onDelete: Cascade)
  material     MaterialImpactEstimate @relation(fields: [materialTypeId], references: [id])

  @@unique([storeProductId, materialTypeId]) // Prevent duplicate materials
  @@index([storeProductId])
  @@index([materialTypeId])
  @@index([isPrimary])
  @@index([isRecycled])
  @@index([sourceMaterial])
}

model ProductVariant {
  id             Int          @id @default(autoincrement())
  storeProductId Int
  name           String
  price          Int
  stock          Int
  color          String?
  size           String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime
  product        StoreProduct @relation(fields: [storeProductId], references: [id])

  @@unique([storeProductId, color, size])
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                    SERVICES
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
model ServiceCategory {
  id            Int                  @id @default(autoincrement())
  category      String               @unique
  subcategories ServiceSubCategory[]
}

model ServiceSubCategory {
  id                Int             @id @default(autoincrement())
  subCategory       String
  serviceCategoryId Int
  serviceCategory   ServiceCategory @relation(fields: [serviceCategoryId], references: [id])
  services          Service[]
}

model Service {
  id              Int                @id @default(autoincrement())
  name            String
  description     String?
  sellerId        String
  subcategoryId   Int
  pricingType     ServicePricing     @default(QUOTATION)
  basePrice       Float?
  priceRange      String?
  duration        Int?
  isActive        Boolean            @default(true)
  images          String[]
  tags            String[]
  createdAt       DateTime           @default(now())
  updatedAt       DateTime
  quotation       Quotation[]
  advertisement   Advertisement[]
  serviceCategory ServiceSubCategory @relation(fields: [subcategoryId], references: [id])
  seller          Seller             @relation(fields: [sellerId], references: [id])
  serviceReview   ServiceReview[]

  @@index([subcategoryId])
  @@index([isActive])
  @@index([pricingType])
  @@index([sellerId])
  @@index([sellerId, isActive]) // Active services by seller
  @@index([subcategoryId, isActive]) // Active services by category
  @@index([sellerId, isActive, pricingType]) // Filter services by seller, status, and pricing
  @@index([createdAt(sort: Desc), isActive]) // Recent active services
}

model ServiceReview {
  id         Int      @id @default(autoincrement())
  serviceId  Int
  reviewerId String
  rating     Int
  comment    String?
  createdAt  DateTime @default(now())
  seller     Seller   @relation(fields: [reviewerId], references: [id])
  service    Service  @relation(fields: [serviceId], references: [id])
}

model Quotation {
  id                                  Int             @id @default(autoincrement())
  serviceId                           Int
  clientId                            String
  providerId                          String
  title                               String
  description                         String
  estimatedPrice                      Float?
  finalPrice                          Float?
  estimatedDuration                   Int?
  status                              QuotationStatus @default(PENDING)
  clientNotes                         String?
  providerNotes                       String?
  attachments                         String[]
  createdAt                           DateTime        @default(now())
  updatedAt                           DateTime
  expiresAt                           DateTime?
  acceptedAt                          DateTime?
  completedAt                         DateTime?
  payment                             Payment[]
  seller_Quotation_clientIdToSeller   Seller          @relation("Quotation_clientIdToSeller", fields: [clientId], references: [id])
  seller_Quotation_providerIdToSeller Seller          @relation("Quotation_providerIdToSeller", fields: [providerId], references: [id])
  service                             Service         @relation(fields: [serviceId], references: [id])
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                    SOCIAL AND BLOG
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

model BlogPost {
  id             Int            @id @default(autoincrement())
  title          String
  content        String
  authorId       String
  isPublished    Boolean        @default(false)
  publishedAt    DateTime?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime
  blogCategoryId Int
  likes          Int            @default(0)
  dislikes       Int            @default(0)
  blogCategory   BlogCategory   @relation(fields: [blogCategoryId], references: [id])
  type           BlogType       @default(OTHER)
  author         Admin          @relation(fields: [authorId], references: [id])
  blogReactions  BlogReaction[] // Track individual user reactions

  @@index([type])
  @@index([isPublished])
  @@index([publishedAt])
}

// Track individual user reactions to blog posts
// Ensures users can only like OR dislike once, and can toggle their choice
model BlogReaction {
  id         Int              @id @default(autoincrement())
  blogPostId Int
  sellerId   String // User who reacted
  reaction   BlogReactionType // LIKE or DISLIKE
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  blogPost BlogPost @relation(fields: [blogPostId], references: [id], onDelete: Cascade)
  seller   Seller   @relation(fields: [sellerId], references: [id], onDelete: Cascade)

  @@unique([blogPostId, sellerId]) // One reaction per user per post
  @@index([blogPostId])
  @@index([sellerId])
  @@index([reaction])
  @@index([blogPostId, reaction]) // Count likes/dislikes efficiently
}

model BlogCategory {
  id          Int        @id @default(autoincrement())
  name        String     @unique
  icon        String
  description String
  posts       BlogPost[]
}

model CommunityComment {
  id              Int           @id @default(autoincrement())
  communityPostId Int
  sellerId        String
  content         String
  createdAt       DateTime      @default(now())
  updatedAt       DateTime
  communityPost   CommunityPost @relation(fields: [communityPostId], references: [id])
  seller          Seller        @relation(fields: [sellerId], references: [id])

  @@index([communityPostId])
  @@index([createdAt])
  @@index([sellerId])
}

model CommunityPost {
  id               Int                @id @default(autoincrement())
  authorId         String
  title            String
  content          String
  images           String[]
  likes            Int                @default(0)
  comments         Int                @default(0)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime
  communityComment CommunityComment[]
  author           Admin              @relation(fields: [authorId], references: [id])

  @@index([createdAt])
  @@index([authorId])
}

model CommunityCategory {
  id            Int                    @id @default(autoincrement())
  category      String                 @unique
  subcategories CommunitySubCategory[]
}

model CommunitySubCategory {
  id                  Int               @id @default(autoincrement())
  subCategory         String
  communityCategoryId Int
  communityCategory   CommunityCategory @relation(fields: [communityCategoryId], references: [id])
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                    TRANSACTIONS
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
model Transaction {
  id              Int             @id @default(autoincrement())
  kind            TransactionKind
  pointsCollected Int
  createdAt       DateTime        @default(now())
  sellerId        String

  // Transaction fee applied (based on seller type)
  transactionFeeId Int?
  transactionFee   TransactionFee? @relation(fields: [transactionFeeId], references: [id])

  exchange Exchange?
  seller   Seller    @relation(fields: [sellerId], references: [id])

  @@index([sellerId, kind]) // Query transaction history by seller and type
  @@index([sellerId, createdAt(sort: Desc)]) // Recent transactions by seller
  @@index([createdAt]) // Time-based queries
  @@index([transactionFeeId])
}

model Exchange {
  id                                           Int            @id @default(autoincrement())
  transactionId                                Int            @unique
  offeredProductId                             Int
  requestedProductId                           Int
  status                                       ExchangeStatus @default(PENDING)
  notes                                        String?
  createdAt                                    DateTime       @default(now())
  completedAt                                  DateTime?
  product_Exchange_offeredProductIdToProduct   Product        @relation("Exchange_offeredProductIdToProduct", fields: [offeredProductId], references: [id])
  product_Exchange_requestedProductIdToProduct Product        @relation("Exchange_requestedProductIdToProduct", fields: [requestedProductId], references: [id])
  transaction                                  Transaction    @relation(fields: [transactionId], references: [id])
}

model Payment {
  id                                Int                    @id @default(autoincrement())
  orderId                           Int?
  quotationId                       Int?
  paymentType                       PaymentType // ORDER or QUOTATION
  amount                            Float
  currency                          String                 @default("CLP") // Chilean Peso
  status                            PaymentStatus          @default(PENDING)
  paymentProvider                   ChileanPaymentProvider // KHIPU or WEBPAY
  externalId                        String?                @unique // Khipu payment_id or WebPay buy_order
  externalToken                     String? // Khipu notification_token or WebPay token
  description                       String?
  fees                              Float?                 @default(0)
  netAmount                         Float?
  payerId                           String
  receiverId                        String
  failureReason                     String?
  metadata                          Json? // Provider-specific data
  createdAt                         DateTime               @default(now())
  updatedAt                         DateTime
  processedAt                       DateTime?
  refundedAt                        DateTime?
  chileanConfigId                   Int // Required - links to provider config
  chileanPaymentConfig              ChileanPaymentConfig   @relation(fields: [chileanConfigId], references: [id])
  order                             Order?                 @relation(fields: [orderId], references: [id])
  seller_Payment_payerIdToSeller    Seller                 @relation("Payment_payerIdToSeller", fields: [payerId], references: [id])
  quotation                         Quotation?             @relation(fields: [quotationId], references: [id])
  seller_Payment_receiverIdToSeller Seller                 @relation("Payment_receiverIdToSeller", fields: [receiverId], references: [id])
  paymentRefund                     PaymentRefund[]
  paymentTransaction                PaymentTransaction[]
  paymentWebhook                    PaymentWebhook[]

  @@index([createdAt])
  @@index([orderId])
  @@index([payerId])
  @@index([quotationId])
  @@index([receiverId])
  @@index([status])
  @@index([paymentProvider])
  @@index([externalId])
  @@index([payerId, status]) // Payments by payer and status
  @@index([receiverId, status]) // Payments received by status
}

model PaymentRefund {
  id          Int          @id @default(autoincrement())
  paymentId   Int
  amount      Float
  reason      String
  status      RefundStatus @default(PENDING)
  externalId  String?
  createdAt   DateTime     @default(now())
  processedAt DateTime?
  payment     Payment      @relation(fields: [paymentId], references: [id])

  @@index([paymentId])
  @@index([status])
}

model PaymentTransaction {
  id          Int      @id @default(autoincrement())
  paymentId   Int
  action      String
  amount      Float?
  status      String
  description String?
  metadata    Json?
  createdAt   DateTime @default(now())
  createdBy   String?
  payment     Payment  @relation(fields: [paymentId], references: [id])

  @@index([action])
  @@index([createdAt])
  @@index([paymentId])
}

// Payment configuration for Chilean providers (Khipu, Webpay)
// NOTE: When expanding to other countries, create similar models:
// - ArgentinaPaymentConfig (Mercado Pago, etc.)
// - PeruPaymentConfig (Culqi, Niubiz, etc.)
// - MexicoPaymentConfig (Conekta, OpenPay, etc.)
// Or create a generic PaymentConfig model with provider-specific JSON fields
model ChileanPaymentConfig {
  id          Int                    @id @default(autoincrement())
  sellerId    String
  provider    ChileanPaymentProvider // KHIPU or WEBPAY
  merchantId  String? // Khipu receiver_id or WebPay commerce_code
  apiKey      String? // Khipu secret or WebPay API key
  secretKey   String? // WebPay secret key
  environment PaymentEnvironment     @default(SANDBOX)
  isActive    Boolean                @default(true)
  webhookUrl  String?
  returnUrl   String?
  cancelUrl   String?
  createdAt   DateTime               @default(now())
  updatedAt   DateTime
  seller      Seller                 @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  payment     Payment[]

  @@unique([sellerId, provider])
  @@index([provider])
  @@index([sellerId])
}

model PaymentWebhook {
  id              Int                    @id @default(autoincrement())
  paymentId       Int?
  provider        ChileanPaymentProvider // KHIPU or WEBPAY
  eventType       String // Khipu: "payment", WebPay: "AUTHORIZED", etc.
  externalId      String // Khipu notification_id or WebPay transaction ID
  payload         Json // Full webhook payload
  processed       Boolean                @default(false)
  processingError String?
  createdAt       DateTime               @default(now())
  processedAt     DateTime?
  payment         Payment?               @relation(fields: [paymentId], references: [id])

  @@index([paymentId])
  @@index([processed])
  @@index([provider])
  @@index([externalId])
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                    ORDERS AND NOTIFICATIONS
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
model ShippingStatus {
  id     Int           @id @default(autoincrement())
  status ShippingStage @default(PREPARING)
  order  Order[]
}

model Order {
  id               Int            @id @default(autoincrement())
  sellerId         String
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  shippingStatusId Int
  version          Int            @default(0) // Optimistic locking - increment on each update
  seller           Seller         @relation(fields: [sellerId], references: [id])
  shippingStatus   ShippingStatus @relation(fields: [shippingStatusId], references: [id])
  orderItem        OrderItem[]
  payment          Payment[]

  @@index([sellerId])
  @@index([shippingStatusId])
  @@index([createdAt(sort: Desc)])
}

model OrderItem {
  id        Int      @id @default(autoincrement())
  orderId   Int
  productId Int
  quantity  Int
  createdAt DateTime @default(now())
  order     Order    @relation(fields: [orderId], references: [id])
  product   Product  @relation(fields: [productId], references: [id])

  @@index([orderId])
  @@index([productId])
}

model Message {
  id        Int      @id @default(autoincrement())
  chatId    Int
  senderId  String
  content   String
  createdAt DateTime @default(now())
  chat      Chat     @relation(fields: [chatId], references: [id])
  seller    Seller   @relation(fields: [senderId], references: [id])
}

model Notification {
  id        Int                  @id @default(autoincrement())
  sellerId  String
  type      NotificationType
  title     String
  message   String
  isRead    Boolean              @default(false)
  priority  NotificationPriority @default(MEDIUM)
  relatedId String?
  actionUrl String?
  metadata  Json?
  createdAt DateTime             @default(now())
  readAt    DateTime?
  seller    Seller               @relation(fields: [sellerId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([isRead])
  @@index([sellerId])
  @@index([type])
}

model NotificationTemplate {
  id        Int              @id @default(autoincrement())
  type      NotificationType @unique
  title     String
  message   String
  isActive  Boolean          @default(true)
  createdAt DateTime         @default(now())
  updatedAt DateTime

  @@index([type])
}

// IMPORTANT: Exchanges are ONLY allowed for PERSON sellers
// Business accounts (STARTUP/COMPANY) cannot participate in exchanges
// Application must enforce: only products where seller.sellerType = 'PERSON' can be exchangeable
// This is enforced at the application level, not in the database
model Match {
  id                              Int      @id @default(autoincrement())
  senderId                        String
  receiverId                      String
  createdAt                       DateTime @default(now())
  updatedAt                       DateTime @updatedAt
  isMatched                       Boolean  @default(false)
  seller_Match_receiverIdToSeller Seller   @relation("Match_receiverIdToSeller", fields: [receiverId], references: [id])
  seller_Match_senderIdToSeller   Seller   @relation("Match_senderIdToSeller", fields: [senderId], references: [id])

  @@index([senderId])
  @@index([receiverId])
  @@index([isMatched])
}

model Chat {
  id                             Int       @id @default(autoincrement())
  senderId                       String
  receiverId                     String
  productId                      Int?
  isExchange                     Boolean   @default(false)
  createdAt                      DateTime  @default(now())
  product                        Product?  @relation(fields: [productId], references: [id])
  seller_Chat_receiverIdToSeller Seller    @relation("Chat_receiverIdToSeller", fields: [receiverId], references: [id])
  seller_Chat_senderIdToSeller   Seller    @relation("Chat_senderIdToSeller", fields: [senderId], references: [id])
  message                        Message[]
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                    IMPACT 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
model WaterImpactMessage {
  id       Int    @id @default(autoincrement())
  min      Float  @default(0.0)
  max      Float  @default(0.0)
  message1 String
  message2 String
  message3 String
}

model Co2ImpactMessage {
  id       Int    @id @default(autoincrement())
  min      Float  @default(0.0)
  max      Float  @default(0.0)
  message1 String
  message2 String
  message3 String
}

model MaterialImpactEstimate {
  id                       Int                       @id @default(autoincrement())
  materialType             String                    @unique
  estimatedCo2SavingsKG    Float
  estimatedWaterSavingsLT  Float
  // Junction table relations for flexible material tracking
  productCategoryMaterials ProductCategoryMaterial[]
  storeProductMaterials    StoreProductMaterial[]

  @@index([materialType])
}

model ProductComment {
  id             Int          @id @default(autoincrement())
  comment        String
  storeProductId Int
  sellerId       String
  createdAt      DateTime     @default(now())
  rating         Int?
  storeProduct   StoreProduct @relation(fields: [storeProductId], references: [id])
  seller         Seller       @relation(fields: [sellerId], references: [id])
}

model ProductLike {
  id             Int          @id @default(autoincrement())
  storeProductId Int
  sellerId       String
  createdAt      DateTime     @default(now())
  storeProduct   StoreProduct @relation(fields: [storeProductId], references: [id])
  seller         Seller       @relation(fields: [sellerId], references: [id])

  @@unique([storeProductId, sellerId]) // Prevent duplicate likes
  @@index([storeProductId])
  @@index([sellerId])
  @@index([createdAt(sort: Desc)])
}

model Story {
  id          Int      @id @default(autoincrement())
  images      String[]
  title       String
  description String
  sellerId    String
  seller      Seller   @relation(fields: [sellerId], references: [id])
}
